<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>é›»è¦–ç‰†</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { background: #000; text-align: center; margin: 0; color: #fff; }
    header { padding: 10px 0; }
    #controls { margin-bottom: 8px; }
    canvas { background: #fff; display:block; margin: 0 auto 20px; box-shadow: 0 4px 14px rgba(0,0,0,0.6); }
    #status { font-size: 13px; opacity: 0.8; }
  </style>
</head>
<body>
  <header>
    <h1>ğŸ–¼ï¸ é›»è¦–ç‰†é¡¯ç¤ºå€</h1>
    <div id="controls">
      <span id="status">é€£ç·šä¸­...</span>
      &nbsp;|&nbsp;
      æ”¾å¤§å€ç‡: <select id="pixelScale"><option value="2">2x</option><option value="4" selected>4x</option><option value="8">8x</option></select>
      &nbsp;|&nbsp;
      <button id="clearBtn">æ¸…é™¤ç•«é¢</button>
    </div>
  </header>

  <canvas id="tv"></canvas>

<script>
(function(){
  const canvas = document.getElementById('tv');
  const ctx = canvas.getContext('2d');
  const statusEl = document.getElementById('status');
  const pixelScaleSelect = document.getElementById('pixelScale');
  const clearBtn = document.getElementById('clearBtn');

  // åŸºç¤ã€Œé‚è¼¯ç•«å¸ƒã€å°ºå¯¸ï¼ˆä»¥åƒç´ æ ¼ç‚ºå–®ä½ï¼‰
  // ä½ å¯ä»¥æ”¹æˆ 200x200 æˆ–æ›´å¤§ï¼Œè¦–é¡¯ç¤ºèˆ‡ç¶²è·¯é »å¯¬éœ€æ±‚
  const LOGICAL_W = 200;
  const LOGICAL_H = 200;

  // è¨­å®šç•«å¸ƒå¯¦éš›å¤§å°ï¼ˆä¾ devicePixelRatio èˆ‡ scaleï¼‰
  let pixelScale = parseInt(pixelScaleSelect.value, 10) || 4;
  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const displayW = LOGICAL_W * pixelScale;
    const displayH = LOGICAL_H * pixelScale;
    canvas.style.width = displayW + 'px';
    canvas.style.height = displayH + 'px';
    canvas.width = Math.floor(displayW * dpr);
    canvas.height = Math.floor(displayH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // æ”¯æ´é«˜ DPI
    // èƒŒæ™¯ç™½
    ctx.fillStyle = '#fff';
    ctx.fillRect(0,0, displayW, displayH);
  }
  pixelScaleSelect.addEventListener('change', () => {
    pixelScale = parseInt(pixelScaleSelect.value, 10) || 4;
    resizeCanvas();
  });

  // æ¸…é™¤ç•«é¢
  function clearCanvas() {
    const displayW = LOGICAL_W * pixelScale;
    const displayH = LOGICAL_H * pixelScale;
    ctx.fillStyle = '#fff';
    ctx.fillRect(0,0, displayW, displayH);
  }
  clearBtn.addEventListener('click', () => {
    clearCanvas();
  });

  // ç¹ªè£½å–®ä¸€é»ï¼ˆä»¥é‚è¼¯åº§æ¨™ x,y ç‚ºåŸºæº–ï¼‰
  function drawPixel(x, y, color, size = 1) {
    // color å¯èƒ½ç‚º "#000000" æˆ– rgbaï¼Œsize ä»¥é‚è¼¯å–®ä½ç‚ºæº–
    ctx.fillStyle = color || '#000';
    ctx.fillRect(Math.floor(x * pixelScale), Math.floor(y * pixelScale),
                 Math.max(1, Math.floor(size * pixelScale)),
                 Math.max(1, Math.floor(size * pixelScale)));
  }

  // ç•« continuous stroke çš„ç°¡æ˜“ç¨‹å¼ï¼ˆç”¨æœ€ç°¡å–®çš„æ”¾å¤§ç•«æ–¹å¡Šï¼‰
  // æ”¯æ´ä¾†è‡ª begin/draw/end æˆ–ç°¡å–® draw é»è¨Šæ¯
  const activeStrokes = {}; // stroke_id -> last point
  function handleBegin(msg) {
    // msg: {type:'begin', x, y, color, width, stroke_id}
    activeStrokes[msg.stroke_id] = { x: msg.x, y: msg.y, color: msg.color, width: msg.width };
    // ç•«èµ·é»
    drawPixel(msg.x, msg.y, msg.color || '#000', msg.width || 1);
  }
  function handleDraw(msg) {
    // msg: {type:'draw', x, y, stroke_id, color?, width?}
    if (msg.stroke_id && activeStrokes[msg.stroke_id]) {
      // ç°¡å–®åœ°åœ¨ç•¶å‰åº§æ¨™ç•«é»ï¼ˆé›»è¦–ç‰†ç”¨æ–¹å¡Šæ›´é†’ç›®ï¼‰
      const s = activeStrokes[msg.stroke_id];
      drawPixel(msg.x, msg.y, s.color || msg.color || '#000', s.width || msg.width || 1);
      s.x = msg.x; s.y = msg.y;
    } else {
      // å¦‚æœæ˜¯å–®é» drawï¼ˆæ²’æœ‰ stroke_idï¼‰ï¼Œç›´æ¥ç•«
      if (typeof msg.x === 'number' && typeof msg.y === 'number') {
        const color = msg.color || '#000';
        const width = msg.width || msg.size || 1;
        drawPixel(msg.x, msg.y, color, width);
      }
    }
  }
  function handleEnd(msg) {
    // msg: {type:'end', stroke_id}
    if (msg.stroke_id) delete activeStrokes[msg.stroke_id];
  }

  // è§£æä¾†è‡ª WebSocket çš„è¨Šæ¯
  function onWsMessage(evt) {
    let msg;
    try { msg = JSON.parse(evt.data); } catch(e) { return; }
    // æ”¯æ´å¤šç¨®æ ¼å¼ï¼šbegin/draw/end æˆ– type:'draw' æœ‰ x,y,color,width
    if (msg.type === 'begin') handleBegin(msg);
    else if (msg.type === 'draw') handleDraw(msg);
    else if (msg.type === 'end') handleEnd(msg);
    else if (msg.type === 'clear') clearCanvas();
    else if (msg.type === 'frame' && Array.isArray(msg.pixels)) {
      // å¯é¸ï¼šä¸€æ¬¡æ¥æ”¶æ•´å€‹åƒç´ é™£åˆ—ï¼ˆæ¯é … {x,y,color}ï¼‰
      msg.pixels.forEach(p => drawPixel(p.x, p.y, p.color || '#000', p.size || 1));
    }
  }

  // WebSocket é€£ç·šï¼ˆé€£åˆ° /ws/tv æˆ¿é–“ï¼‰
  const host = location.hostname;
  const port = 8000; // è‹¥ä½ çš„ server port ä¸åŒï¼Œæ”¹é€™è£¡
  const wsUrl = `${location.protocol === 'https:' ? 'wss' : 'ws'}://${host}:${port}/ws/tv`;
  const socket = new WebSocket(wsUrl);

  socket.addEventListener('open', () => {
    statusEl.textContent = 'å·²é€£ç·šåˆ° TVï¼ˆæˆ¿é–“: tvï¼‰';
    statusEl.style.color = '#8f8';
    // å¯å‘ server è¨»å†Šï¼š{type:'join', user:'tv-display'}
    socket.send(JSON.stringify({ type:'join', user: 'tv-display' }));
  });
  socket.addEventListener('message', onWsMessage);
  socket.addEventListener('close', () => {
    statusEl.textContent = 'WebSocket å·²æ–·ç·š';
    statusEl.style.color = '#f88';
  });
  socket.addEventListener('error', () => {
    statusEl.textContent = 'WebSocket éŒ¯èª¤';
    statusEl.style.color = '#f88';
  });

  // åˆå§‹è¨­å®š
  resizeCanvas();
  clearCanvas();
  // ç¢ºä¿ç•«å¸ƒåœ¨è¦–çª—æ”¹è®Šæ™‚é‡æ–°è¨ˆç®—å¤§å°
  window.addEventListener('resize', () => {
    resizeCanvas();
    // ä¸è¦è‡ªå‹•æ¸…é™¤å…§å®¹ï¼Œä»¥å…æ”¾å¤§å¾Œå¤±çœŸï¼›è‹¥è¦é‡æ–°æ¸²æŸ“ï¼Œserver éœ€è¦é‡å‚³ frame
  });
})();
</script>
</body>
</html>
