<!doctype html>
<html lang="zh-TW">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>å¤šäººç•«ç•«åŒæ­¥</title>
<style>
  body { margin:0; background:#222; color:#fff; font-family:sans-serif; }
  #toolbar { display:flex; gap:10px; padding:10px; background:#333; align-items:center; justify-content: space-between; }
  #left-toolbar { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  #canvas {
    display:block;
    background:#fff;
    touch-action:none;
    margin:0 auto;
  }
  button,input[type=color],input[type=range] {
    padding:6px; border-radius:6px; border:none;
  }
  button { cursor:pointer; }
  #qrCode { width:80px; height:80px; }

  /* ğŸ“– AI æ•…äº‹å€ */
  #storyBox {
    position:fixed;
    bottom:0;
    left:0;
    right:0;
    max-height:40%;
    overflow:auto;
    background:rgba(0,0,0,0.85);
    color:#fff;
    padding:16px;
    font-size:18px;
    display:none;
    line-height:1.6;
    z-index:999;
  }
</style>
</head>
<body>

<div id="toolbar">
  <div id="left-toolbar">
    <button id="pen">âœï¸ ç­†åˆ·</button>
    <button id="eraser">ğŸ§½ æ©¡çš®æ“¦</button>
    <input type="color" id="colorPicker" value="#000000">
    <input type="range" id="sizePicker" min="2" max="40" value="5">
    <button id="clear">ğŸ—‘ï¸ æ¸…é™¤</button>
    <button id="save">ğŸ’¾ å„²å­˜</button>
    <button id="aiTheme">ğŸ² ä¸»é¡Œ</button>
    <button id="aiStory">ğŸ“– AI æ•…äº‹</button>
    <span id="themeText" style="margin-left:10px;"></span>
    <button id="controlMode">ğŸ® æ§åˆ¶ï¼šé—œ</button>
  </div>
  <canvas id="qrCode"></canvas>
</div>

<canvas id="canvas"></canvas>

<div id="storyBox"></div>

<script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
<script>
// =====================
// ğŸ”’ è™›æ“¬ç•«å¸ƒè¨­å®š
// =====================
const VIRTUAL_WIDTH = 1920;
const VIRTUAL_HEIGHT = 1080;

// URL åƒæ•¸
const params = new URLSearchParams(location.search);
const room = params.get("room") || "room1";
const name = params.get("name") || "user_" + Math.floor(Math.random()*9999);

// Canvas
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize(){
  const scaleX = window.innerWidth / VIRTUAL_WIDTH;
  const scaleY = (window.innerHeight - 60) / VIRTUAL_HEIGHT;
  const scale = Math.min(scaleX, scaleY);
  canvas.width = VIRTUAL_WIDTH;
  canvas.height = VIRTUAL_HEIGHT;
  canvas.style.width = VIRTUAL_WIDTH * scale + "px";
  canvas.style.height = VIRTUAL_HEIGHT * scale + "px";
}
resize();
window.addEventListener("resize", resize);

// åº§æ¨™è½‰æ›
function getVirtualPos(e){
  const rect = canvas.getBoundingClientRect();
  return {
    x: (e.clientX - rect.left) * (VIRTUAL_WIDTH / rect.width),
    y: (e.clientY - rect.top) * (VIRTUAL_HEIGHT / rect.height)
  };
}

// ç‹€æ…‹
let drawing = false;
let mode = "pen";
let currentColor = colorPicker.value;
let currentSize = sizePicker.value;
let lastX = 0, lastY = 0;
let strokeId = null;
let controlModeActive = false;

// å·¥å…·
pen.onclick = () => mode="pen";
eraser.onclick = () => mode="eraser";
colorPicker.oninput = e => currentColor = e.target.value;
sizePicker.oninput = e => currentSize = e.target.value;

clear.onclick = () => {
  ctx.clearRect(0,0,VIRTUAL_WIDTH,VIRTUAL_HEIGHT);
  send({type:"clear"});
};

save.onclick = () => {
  const a = document.createElement("a");
  a.download = `canvas_${Date.now()}.png`;
  a.href = canvas.toDataURL();
  a.click();
};

aiTheme.onclick = () => send({type:"generateTheme"});

controlMode.onclick = () => {
  controlModeActive = !controlModeActive;
  controlMode.textContent = controlModeActive ? "ğŸ® æ§åˆ¶ï¼šé–‹" : "ğŸ® æ§åˆ¶ï¼šé—œ";
};

// WebSocket
const ws = new WebSocket(`${location.protocol==='https:'?'wss':'ws'}://${location.host}/ws/${room}`);

ws.onmessage = e => {
  const m = JSON.parse(e.data);
  if(m.type==="draw") drawFromServer(m);
  if(m.type==="clear") ctx.clearRect(0,0,VIRTUAL_WIDTH,VIRTUAL_HEIGHT);
  if(m.type==="topic") themeText.textContent = "ğŸ¨ " + m.value;
  // âœ… AI æ•…äº‹åŒæ­¥é¡¯ç¤º
  if(m.type === "story"){
    storyBox.style.display = "block";
    storyBox.textContent = "ğŸ“– " + m.title + "\n\n" + m.story;
  }
};

function send(data){
  data.sender = name;
  ws.send(JSON.stringify(data));
}

// ç•«ç•«
const remotePaths = {};

function startDraw(p){
  drawing = true;
  lastX = p.x;
  lastY = p.y;
  strokeId = Date.now()+"_"+Math.random();
  send({type:"draw", begin:true, strokeId, mode, color:currentColor, size:currentSize, x:lastX, y:lastY});
}

function moveDraw(p){
  drawLine(lastX,lastY,p.x,p.y,mode,currentColor,currentSize);
  send({type:"draw", strokeId, mode, color:currentColor, size:currentSize, x:p.x, y:p.y});
  lastX = p.x;
  lastY = p.y;
}

canvas.onpointerdown = e => { if(!controlModeActive) startDraw(getVirtualPos(e)); };
canvas.onpointermove = e => { if(drawing && !controlModeActive) moveDraw(getVirtualPos(e)); };
canvas.onpointerup = canvas.onpointerleave = () => drawing=false;

// ç•«ç·š
function drawLine(x1,y1,x2,y2,mode,color,size){
  ctx.lineCap="round";
  ctx.lineJoin="round";
  ctx.lineWidth=size;
  ctx.strokeStyle = mode==="pen" ? color : "#fff";
  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.lineTo(x2,y2);
  ctx.stroke();
}

function drawFromServer(m){
  if(m.sender===name) return;
  remotePaths[m.sender] ??= {};
  if(m.begin){
    remotePaths[m.sender][m.strokeId] = {x:m.x,y:m.y};
    return;
  }
  const p = remotePaths[m.sender][m.strokeId];
  if(!p) return;
  drawLine(p.x,p.y,m.x,m.y,m.mode,m.color,m.size);
  remotePaths[m.sender][m.strokeId] = {x:m.x,y:m.y};
}

// ğŸ“– AI æ•…äº‹
const storyBox = document.getElementById("storyBox");
aiStory.onclick = async () => {
  storyBox.style.display = "block";
  storyBox.textContent = "ğŸ§  AI æ­£åœ¨ç”Ÿæˆæ•…äº‹ä¸­...";

  try{
    const res = await fetch("/ai/story",{
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({
        room,
        theme: themeText.textContent || "è‡ªç”±å‰µä½œ",
        canvas: canvas.toDataURL()
      })
    });
aiStory.onclick = async () => {
  storyBox.style.display = "block";
  storyBox.textContent = "ğŸ§  AI æ­£åœ¨ç”Ÿæˆæ•…äº‹ä¸­...";

  await fetch("/ai/story", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({
      room,
      theme: themeText.textContent || "è‡ªç”±å‰µä½œ",
      canvas: canvas.toDataURL()
    })
  });
};

// -------- æ§åˆ¶æ¨¡å¼ï¼ˆæ»‘å‹•ï¼‰ --------
let sx=0, sy=0;
canvas.addEventListener("touchstart", e=>{
  if(!controlModeActive) return;
  const t=e.changedTouches[0];
  sx=t.pageX; sy=t.pageY;
});
canvas.addEventListener("touchend", e=>{
  if(!controlModeActive) return;
  const t=e.changedTouches[0];
  const dx=t.pageX-sx, dy=t.pageY-sy;
  if(Math.abs(dx)<30 && Math.abs(dy)<30) return;
  send({type:"moveFocus", direction: Math.abs(dx)>Math.abs(dy) ? (dx>0?"right":"left") : (dy>0?"down":"up")});
});

// -------- é›»è¦–ç‰†ç„¦é» --------
function drawFocusArea(dir){
  ctx.clearRect(0,0,VIRTUAL_WIDTH,VIRTUAL_HEIGHT);
  ctx.fillStyle="rgba(255,200,0,0.25)";
  if(dir==="up") ctx.fillRect(0,0,VIRTUAL_WIDTH,VIRTUAL_HEIGHT/3);
  if(dir==="down") ctx.fillRect(0,VIRTUAL_HEIGHT*2/3,VIRTUAL_WIDTH,VIRTUAL_HEIGHT/3);
  if(dir==="left") ctx.fillRect(0,0,VIRTUAL_WIDTH/3,VIRTUAL_HEIGHT);
  if(dir==="right") ctx.fillRect(VIRTUAL_WIDTH*2/3,0,VIRTUAL_WIDTH/3,VIRTUAL_HEIGHT);
}

// -------- QR --------
QRCode.toCanvas(qrCode, `${location.origin}?room=${room}`, {width:80});
</script>
</body>
</html>



















